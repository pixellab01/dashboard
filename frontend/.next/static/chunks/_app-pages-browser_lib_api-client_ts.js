"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_api-client_ts"],{

/***/ "(app-pages-browser)/./lib/api-client.ts":
/*!***************************!*\
  !*** ./lib/api-client.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildQueryString: function() { return /* binding */ buildQueryString; },\n/* harmony export */   computeAnalytics: function() { return /* binding */ computeAnalytics; },\n/* harmony export */   fetchAnalytics: function() { return /* binding */ fetchAnalytics; },\n/* harmony export */   generateSessionId: function() { return /* binding */ generateSessionId; },\n/* harmony export */   getFilterOptions: function() { return /* binding */ getFilterOptions; },\n/* harmony export */   getGoogleDriveAuthUrl: function() { return /* binding */ getGoogleDriveAuthUrl; },\n/* harmony export */   getRawShippingData: function() { return /* binding */ getRawShippingData; },\n/* harmony export */   getSessionStats: function() { return /* binding */ getSessionStats; },\n/* harmony export */   getStats: function() { return /* binding */ getStats; },\n/* harmony export */   getTtlInfo: function() { return /* binding */ getTtlInfo; },\n/* harmony export */   listGoogleDriveFiles: function() { return /* binding */ listGoogleDriveFiles; },\n/* harmony export */   login: function() { return /* binding */ login; },\n/* harmony export */   readGoogleDriveFile: function() { return /* binding */ readGoogleDriveFile; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * API Client for Python Backend\n * Centralized functions for making API calls to the Python backend\n */ const PYTHON_API_URL = process.env.NEXT_PUBLIC_PYTHON_API_URL || \"http://localhost:8000\";\n/**\n * Build query string from filter parameters\n */ function buildQueryString(params) {\n    const searchParams = new URLSearchParams();\n    searchParams.append(\"sessionId\", params.sessionId);\n    if (params.startDate) searchParams.append(\"startDate\", params.startDate);\n    if (params.endDate) searchParams.append(\"endDate\", params.endDate);\n    if (params.orderStatus && params.orderStatus !== \"All\") {\n        searchParams.append(\"orderStatus\", params.orderStatus);\n    }\n    if (params.paymentMethod && params.paymentMethod !== \"All\") {\n        searchParams.append(\"paymentMethod\", params.paymentMethod);\n    }\n    if (params.channel && params.channel !== \"All\") {\n        searchParams.append(\"channel\", params.channel);\n    }\n    if (params.sku && params.sku !== \"All\") {\n        const skuArray = Array.isArray(params.sku) ? params.sku : [\n            params.sku\n        ];\n        skuArray.forEach((sku)=>searchParams.append(\"sku\", sku));\n    }\n    if (params.productName && params.productName !== \"All\") {\n        const productNameArray = Array.isArray(params.productName) ? params.productName : [\n            params.productName\n        ];\n        productNameArray.forEach((productName)=>searchParams.append(\"productName\", productName));\n    }\n    return searchParams.toString();\n}\n/**\n * Fetch analytics data from Python backend\n * Wraps the response to match frontend expectations\n */ async function fetchAnalytics(endpoint, params) {\n    try {\n        const queryString = buildQueryString(params);\n        const url = \"\".concat(PYTHON_API_URL, \"/api/analytics/\").concat(endpoint, \"?\").concat(queryString);\n        const response = await fetch(url);\n        if (!response.ok) {\n            if (response.status === 404) {\n                // Analytics not found - return empty data\n                return {\n                    success: true,\n                    data: [],\n                    count: 0\n                };\n            }\n            const errorData = await response.json().catch(()=>({\n                    detail: \"Unknown error\"\n                }));\n            return {\n                success: false,\n                error: errorData.detail || errorData.error || \"HTTP \".concat(response.status)\n            };\n        }\n        const data = await response.json();\n        // Python backend returns data directly (array or object)\n        // Wrap it to match frontend expectations\n        return {\n            success: true,\n            data: Array.isArray(data) ? data : data,\n            count: Array.isArray(data) ? data.length : 1\n        };\n    } catch (error) {\n        console.error(\"Error fetching \".concat(endpoint, \":\"), error);\n        return {\n            success: false,\n            error: error.message || \"Network error\"\n        };\n    }\n}\n/**\n * Compute analytics via Python backend\n */ async function computeAnalytics(sessionId, filters) {\n    let asyncMode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    try {\n        const url = \"\".concat(PYTHON_API_URL, \"/api/analytics/compute\").concat(asyncMode ? \"?async_mode=true\" : \"\");\n        const response = await fetch(url, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                sessionId,\n                filters: filters || undefined\n            })\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({\n                    detail: \"Unknown error\"\n                }));\n            return {\n                success: false,\n                error: errorData.detail || errorData.error || \"HTTP \".concat(response.status)\n            };\n        }\n        const data = await response.json();\n        return {\n            success: data.success || true,\n            data: {\n                sessionId: data.sessionId || sessionId,\n                jobId: data.jobId\n            },\n            error: data.error\n        };\n    } catch (error) {\n        console.error(\"Error computing analytics:\", error);\n        return {\n            success: false,\n            error: error.message || \"Network error\"\n        };\n    }\n}\n/**\n * Generate a new session ID\n */ async function generateSessionId() {\n    try {\n        const response = await fetch(\"\".concat(PYTHON_API_URL, \"/api/session/generate\"), {\n            method: \"POST\"\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to generate session ID\");\n        }\n        const data = await response.json();\n        return data.sessionId;\n    } catch (error) {\n        console.error(\"Error generating session ID:\", error);\n        // Fallback: generate client-side session ID\n        return \"session_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9));\n    }\n}\n/**\n * Login user\n */ async function login(email, password) {\n    try {\n        const response = await fetch(\"\".concat(PYTHON_API_URL, \"/api/login\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                email,\n                password\n            })\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({\n                    detail: \"Unknown error\"\n                }));\n            return {\n                success: false,\n                error: errorData.detail || errorData.error || \"HTTP \".concat(response.status)\n            };\n        }\n        const data = await response.json();\n        return {\n            success: data.success || true,\n            data: {\n                user: data.user,\n                message: data.message\n            }\n        };\n    } catch (error) {\n        console.error(\"Error logging in:\", error);\n        return {\n            success: false,\n            error: error.message || \"Network error\"\n        };\n    }\n}\n/**\n * Get dashboard stats\n */ async function getStats() {\n    try {\n        const response = await fetch(\"\".concat(PYTHON_API_URL, \"/api/stats\"));\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({\n                    detail: \"Unknown error\"\n                }));\n            return {\n                success: false,\n                error: errorData.detail || errorData.error || \"HTTP \".concat(response.status)\n            };\n        }\n        const data = await response.json();\n        return {\n            success: data.success || true,\n            data: {\n                totalUsers: data.totalUsers,\n                message: data.message\n            }\n        };\n    } catch (error) {\n        console.error(\"Error fetching stats:\", error);\n        return {\n            success: false,\n            error: error.message || \"Network error\"\n        };\n    }\n}\n/**\n * Get session stats\n */ async function getSessionStats(sessionId) {\n    try {\n        const response = await fetch(\"\".concat(PYTHON_API_URL, \"/api/stats/session?sessionId=\").concat(encodeURIComponent(sessionId)));\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({\n                    detail: \"Unknown error\"\n                }));\n            return {\n                success: false,\n                error: errorData.detail || errorData.error || \"HTTP \".concat(response.status)\n            };\n        }\n        const data = await response.json();\n        return {\n            success: true,\n            data: {\n                sessionId: data.sessionId,\n                isValid: data.isValid,\n                ttl: data.ttl,\n                metadata: data.metadata\n            }\n        };\n    } catch (error) {\n        console.error(\"Error fetching session stats:\", error);\n        return {\n            success: false,\n            error: error.message || \"Network error\"\n        };\n    }\n}\n/**\n * List Google Drive files\n */ async function listGoogleDriveFiles(folderId) {\n    try {\n        const url = folderId ? \"\".concat(PYTHON_API_URL, \"/api/google-drive/files?folderId=\").concat(encodeURIComponent(folderId)) : \"\".concat(PYTHON_API_URL, \"/api/google-drive/files\");\n        const response = await fetch(url);\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({\n                    detail: \"Unknown error\"\n                }));\n            return {\n                success: false,\n                error: errorData.detail || errorData.error || \"HTTP \".concat(response.status)\n            };\n        }\n        const data = await response.json();\n        return {\n            success: data.success || true,\n            data: {\n                files: data.files || []\n            }\n        };\n    } catch (error) {\n        console.error(\"Error listing Google Drive files:\", error);\n        return {\n            success: false,\n            error: error.message || \"Network error\"\n        };\n    }\n}\n/**\n * Read Google Drive file\n */ async function readGoogleDriveFile(fileId) {\n    let sheetType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"shipping\";\n    try {\n        const response = await fetch(\"\".concat(PYTHON_API_URL, \"/api/google-drive/read\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                fileId,\n                sheetType\n            })\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({\n                    detail: \"Unknown error\"\n                }));\n            return {\n                success: false,\n                error: errorData.detail || errorData.error || \"HTTP \".concat(response.status)\n            };\n        }\n        const data = await response.json();\n        return {\n            success: data.success || true,\n            data: {\n                fileName: data.fileName,\n                totalRows: data.totalRows,\n                originalRows: data.originalRows,\n                duplicatesRemoved: data.duplicatesRemoved,\n                headers: data.headers,\n                totalColumns: data.totalColumns,\n                sessionId: data.sessionId,\n                sheetType: data.sheetType,\n                message: data.message\n            }\n        };\n    } catch (error) {\n        console.error(\"Error reading Google Drive file:\", error);\n        return {\n            success: false,\n            error: error.message || \"Network error\"\n        };\n    }\n}\n/**\n * Get Google Drive auth URL\n */ async function getGoogleDriveAuthUrl() {\n    try {\n        const response = await fetch(\"\".concat(PYTHON_API_URL, \"/api/google-drive/auth\"));\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({\n                    detail: \"Unknown error\"\n                }));\n            return {\n                success: false,\n                error: errorData.detail || errorData.error || \"HTTP \".concat(response.status)\n            };\n        }\n        const data = await response.json();\n        return {\n            success: data.success || true,\n            data: {\n                authUrl: data.authUrl,\n                redirectUri: data.redirectUri,\n                message: data.message,\n                instructions: data.instructions\n            }\n        };\n    } catch (error) {\n        console.error(\"Error getting Google Drive auth URL:\", error);\n        return {\n            success: false,\n            error: error.message || \"Network error\"\n        };\n    }\n}\n/**\n * Get raw shipping data\n */ async function getRawShippingData(sessionId, filters, limit) {\n    try {\n        const queryParams = new URLSearchParams();\n        queryParams.append(\"sessionId\", sessionId);\n        if (filters) {\n            if (filters.startDate) queryParams.append(\"startDate\", filters.startDate);\n            if (filters.endDate) queryParams.append(\"filters.endDate\", filters.endDate);\n            if (filters.orderStatus && filters.orderStatus !== \"All\") {\n                queryParams.append(\"orderStatus\", filters.orderStatus);\n            }\n            if (filters.paymentMethod && filters.paymentMethod !== \"All\") {\n                queryParams.append(\"paymentMethod\", filters.paymentMethod);\n            }\n            if (filters.channel && filters.channel !== \"All\") {\n                queryParams.append(\"channel\", filters.channel);\n            }\n            if (filters.sku && filters.sku !== \"All\") {\n                const skuArray = Array.isArray(filters.sku) ? filters.sku : [\n                    filters.sku\n                ];\n                skuArray.forEach((sku)=>queryParams.append(\"sku\", sku));\n            }\n            if (filters.productName && filters.productName !== \"All\") {\n                const productNameArray = Array.isArray(filters.productName) ? filters.productName : [\n                    filters.productName\n                ];\n                productNameArray.forEach((productName)=>queryParams.append(\"productName\", productName));\n            }\n        }\n        if (limit) {\n            queryParams.append(\"limit\", String(limit));\n        }\n        const response = await fetch(\"\".concat(PYTHON_API_URL, \"/api/analytics/raw-shipping?\").concat(queryParams.toString()));\n        if (!response.ok) {\n            if (response.status === 404) {\n                return {\n                    success: true,\n                    data: [],\n                    count: 0\n                };\n            }\n            const errorData = await response.json().catch(()=>({\n                    detail: \"Unknown error\"\n                }));\n            return {\n                success: false,\n                error: errorData.detail || errorData.error || \"HTTP \".concat(response.status)\n            };\n        }\n        const data = await response.json();\n        return {\n            success: true,\n            data: Array.isArray(data) ? data : [],\n            count: Array.isArray(data) ? data.length : 0\n        };\n    } catch (error) {\n        console.error(\"Error fetching raw shipping data:\", error);\n        return {\n            success: false,\n            error: error.message || \"Network error\"\n        };\n    }\n}\n/**\n * Get filter options (channels, SKUs, product names, etc.)\n */ async function getFilterOptions(sessionId) {\n    try {\n        const response = await fetch(\"\".concat(PYTHON_API_URL, \"/api/analytics/filter-options?sessionId=\").concat(encodeURIComponent(sessionId)));\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({\n                    detail: \"Unknown error\"\n                }));\n            return {\n                success: false,\n                error: errorData.detail || errorData.error || \"HTTP \".concat(response.status)\n            };\n        }\n        const data = await response.json();\n        return {\n            success: true,\n            data: {\n                channels: data.channels || [],\n                skus: data.skus || [],\n                productNames: data.productNames || [],\n                statuses: data.statuses || []\n            }\n        };\n    } catch (error) {\n        console.error(\"Error fetching filter options:\", error);\n        return {\n            success: false,\n            error: error.message || \"Network error\"\n        };\n    }\n}\n/**\n * Get TTL info for analytics data\n */ async function getTtlInfo(sessionId) {\n    try {\n        const response = await fetch(\"\".concat(PYTHON_API_URL, \"/api/analytics/ttl-info?sessionId=\").concat(encodeURIComponent(sessionId)));\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({\n                    detail: \"Unknown error\"\n                }));\n            return {\n                success: false,\n                error: errorData.detail || errorData.error || \"HTTP \".concat(response.status)\n            };\n        }\n        const data = await response.json();\n        return {\n            success: true,\n            data: {\n                shipping: data.shipping || {\n                    ttl: 0,\n                    expiresAt: null\n                },\n                analytics: data.analytics || {}\n            }\n        };\n    } catch (error) {\n        console.error(\"Error fetching TTL info:\", error);\n        return {\n            success: false,\n            error: error.message || \"Network error\"\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFoQlgsU0FBU0csTUFBTTtZQUN2RTtRQUNGO1FBRUEsTUFBTUUsT0FBTyxNQUFNTCxTQUFTUSxJQUFJO1FBQ2hDLE9BQU87WUFDTEosU0FBUztZQUNUQyxNQUFNO2dCQUNKK0QsVUFBVS9ELEtBQUsrRCxRQUFRLElBQUk7b0JBQUUzQixLQUFLO29CQUFHNEIsV0FBVztnQkFBSztnQkFDckRDLFdBQVdqRSxLQUFLaUUsU0FBUyxJQUFJLENBQUM7WUFDaEM7UUFDRjtJQUNGLEVBQUUsT0FBTzNELE9BQVk7UUFDbkJFLFFBQVFGLEtBQUssQ0FBQyw0QkFBNEJBO1FBQzFDLE9BQU87WUFDTFAsU0FBUztZQUNUTyxPQUFPQSxNQUFNRyxPQUFPLElBQUk7UUFDMUI7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hcGktY2xpZW50LnRzP2IwOTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBUEkgQ2xpZW50IGZvciBQeXRob24gQmFja2VuZFxuICogQ2VudHJhbGl6ZWQgZnVuY3Rpb25zIGZvciBtYWtpbmcgQVBJIGNhbGxzIHRvIHRoZSBQeXRob24gYmFja2VuZFxuICovXG5cbmNvbnN0IFBZVEhPTl9BUElfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfUFlUSE9OX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMCdcblxuaW50ZXJmYWNlIEFwaVJlc3BvbnNlPFQ+IHtcbiAgc3VjY2VzczogYm9vbGVhblxuICBkYXRhPzogVFxuICBlcnJvcj86IHN0cmluZ1xuICBjb3VudD86IG51bWJlclxufVxuXG4vKipcbiAqIEJ1aWxkIHF1ZXJ5IHN0cmluZyBmcm9tIGZpbHRlciBwYXJhbWV0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFF1ZXJ5U3RyaW5nKHBhcmFtczoge1xuICBzZXNzaW9uSWQ6IHN0cmluZ1xuICBzdGFydERhdGU/OiBzdHJpbmcgfCBudWxsXG4gIGVuZERhdGU/OiBzdHJpbmcgfCBudWxsXG4gIG9yZGVyU3RhdHVzPzogc3RyaW5nXG4gIHBheW1lbnRNZXRob2Q/OiBzdHJpbmdcbiAgY2hhbm5lbD86IHN0cmluZ1xuICBza3U/OiBzdHJpbmcgfCBzdHJpbmdbXVxuICBwcm9kdWN0TmFtZT86IHN0cmluZyB8IHN0cmluZ1tdXG59KTogc3RyaW5nIHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG4gIHNlYXJjaFBhcmFtcy5hcHBlbmQoJ3Nlc3Npb25JZCcsIHBhcmFtcy5zZXNzaW9uSWQpXG4gIFxuICBpZiAocGFyYW1zLnN0YXJ0RGF0ZSkgc2VhcmNoUGFyYW1zLmFwcGVuZCgnc3RhcnREYXRlJywgcGFyYW1zLnN0YXJ0RGF0ZSlcbiAgaWYgKHBhcmFtcy5lbmREYXRlKSBzZWFyY2hQYXJhbXMuYXBwZW5kKCdlbmREYXRlJywgcGFyYW1zLmVuZERhdGUpXG4gIGlmIChwYXJhbXMub3JkZXJTdGF0dXMgJiYgcGFyYW1zLm9yZGVyU3RhdHVzICE9PSAnQWxsJykge1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoJ29yZGVyU3RhdHVzJywgcGFyYW1zLm9yZGVyU3RhdHVzKVxuICB9XG4gIGlmIChwYXJhbXMucGF5bWVudE1ldGhvZCAmJiBwYXJhbXMucGF5bWVudE1ldGhvZCAhPT0gJ0FsbCcpIHtcbiAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKCdwYXltZW50TWV0aG9kJywgcGFyYW1zLnBheW1lbnRNZXRob2QpXG4gIH1cbiAgaWYgKHBhcmFtcy5jaGFubmVsICYmIHBhcmFtcy5jaGFubmVsICE9PSAnQWxsJykge1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoJ2NoYW5uZWwnLCBwYXJhbXMuY2hhbm5lbClcbiAgfVxuICBpZiAocGFyYW1zLnNrdSAmJiBwYXJhbXMuc2t1ICE9PSAnQWxsJykge1xuICAgIGNvbnN0IHNrdUFycmF5ID0gQXJyYXkuaXNBcnJheShwYXJhbXMuc2t1KSA/IHBhcmFtcy5za3UgOiBbcGFyYW1zLnNrdV1cbiAgICBza3VBcnJheS5mb3JFYWNoKHNrdSA9PiBzZWFyY2hQYXJhbXMuYXBwZW5kKCdza3UnLCBza3UpKVxuICB9XG4gIGlmIChwYXJhbXMucHJvZHVjdE5hbWUgJiYgcGFyYW1zLnByb2R1Y3ROYW1lICE9PSAnQWxsJykge1xuICAgIGNvbnN0IHByb2R1Y3ROYW1lQXJyYXkgPSBBcnJheS5pc0FycmF5KHBhcmFtcy5wcm9kdWN0TmFtZSkgPyBwYXJhbXMucHJvZHVjdE5hbWUgOiBbcGFyYW1zLnByb2R1Y3ROYW1lXVxuICAgIHByb2R1Y3ROYW1lQXJyYXkuZm9yRWFjaChwcm9kdWN0TmFtZSA9PiBzZWFyY2hQYXJhbXMuYXBwZW5kKCdwcm9kdWN0TmFtZScsIHByb2R1Y3ROYW1lKSlcbiAgfVxuICBcbiAgcmV0dXJuIHNlYXJjaFBhcmFtcy50b1N0cmluZygpXG59XG5cbi8qKlxuICogRmV0Y2ggYW5hbHl0aWNzIGRhdGEgZnJvbSBQeXRob24gYmFja2VuZFxuICogV3JhcHMgdGhlIHJlc3BvbnNlIHRvIG1hdGNoIGZyb250ZW5kIGV4cGVjdGF0aW9uc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbmFseXRpY3M8VD4oXG4gIGVuZHBvaW50OiBzdHJpbmcsXG4gIHBhcmFtczoge1xuICAgIHNlc3Npb25JZDogc3RyaW5nXG4gICAgc3RhcnREYXRlPzogc3RyaW5nIHwgbnVsbFxuICAgIGVuZERhdGU/OiBzdHJpbmcgfCBudWxsXG4gICAgb3JkZXJTdGF0dXM/OiBzdHJpbmdcbiAgICBwYXltZW50TWV0aG9kPzogc3RyaW5nXG4gICAgY2hhbm5lbD86IHN0cmluZ1xuICAgIHNrdT86IHN0cmluZyB8IHN0cmluZ1tdXG4gICAgcHJvZHVjdE5hbWU/OiBzdHJpbmcgfCBzdHJpbmdbXVxuICB9XG4pOiBQcm9taXNlPEFwaVJlc3BvbnNlPFQ+PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnlTdHJpbmcgPSBidWlsZFF1ZXJ5U3RyaW5nKHBhcmFtcylcbiAgICBjb25zdCB1cmwgPSBgJHtQWVRIT05fQVBJX1VSTH0vYXBpL2FuYWx5dGljcy8ke2VuZHBvaW50fT8ke3F1ZXJ5U3RyaW5nfWBcbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybClcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgLy8gQW5hbHl0aWNzIG5vdCBmb3VuZCAtIHJldHVybiBlbXB0eSBkYXRhXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICBkYXRhOiBbXSBhcyBULFxuICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgZGV0YWlsOiAnVW5rbm93biBlcnJvcicgfSkpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yRGF0YS5kZXRhaWwgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfWAsXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICBcbiAgICAvLyBQeXRob24gYmFja2VuZCByZXR1cm5zIGRhdGEgZGlyZWN0bHkgKGFycmF5IG9yIG9iamVjdClcbiAgICAvLyBXcmFwIGl0IHRvIG1hdGNoIGZyb250ZW5kIGV4cGVjdGF0aW9uc1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgZGF0YTogQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBkYXRhLFxuICAgICAgY291bnQ6IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhLmxlbmd0aCA6IDEsXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgJHtlbmRwb2ludH06YCwgZXJyb3IpXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ05ldHdvcmsgZXJyb3InLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbXB1dGUgYW5hbHl0aWNzIHZpYSBQeXRob24gYmFja2VuZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZUFuYWx5dGljcyhcbiAgc2Vzc2lvbklkOiBzdHJpbmcsXG4gIGZpbHRlcnM/OiB7XG4gICAgc3RhcnREYXRlPzogc3RyaW5nIHwgbnVsbFxuICAgIGVuZERhdGU/OiBzdHJpbmcgfCBudWxsXG4gICAgb3JkZXJTdGF0dXM/OiBzdHJpbmdcbiAgICBwYXltZW50TWV0aG9kPzogc3RyaW5nXG4gICAgY2hhbm5lbD86IHN0cmluZ1xuICAgIHNrdT86IHN0cmluZyB8IHN0cmluZ1tdXG4gICAgcHJvZHVjdE5hbWU/OiBzdHJpbmcgfCBzdHJpbmdbXVxuICB9LFxuICBhc3luY01vZGU6IGJvb2xlYW4gPSBmYWxzZVxuKTogUHJvbWlzZTxBcGlSZXNwb25zZTx7IHNlc3Npb25JZDogc3RyaW5nOyBqb2JJZD86IHN0cmluZyB9Pj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IGAke1BZVEhPTl9BUElfVVJMfS9hcGkvYW5hbHl0aWNzL2NvbXB1dGUke2FzeW5jTW9kZSA/ICc/YXN5bmNfbW9kZT10cnVlJyA6ICcnfWBcbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgIGZpbHRlcnM6IGZpbHRlcnMgfHwgdW5kZWZpbmVkLFxuICAgICAgfSksXG4gICAgfSlcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgZGV0YWlsOiAnVW5rbm93biBlcnJvcicgfSkpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yRGF0YS5kZXRhaWwgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfWAsXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZGF0YS5zdWNjZXNzIHx8IHRydWUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNlc3Npb25JZDogZGF0YS5zZXNzaW9uSWQgfHwgc2Vzc2lvbklkLFxuICAgICAgICBqb2JJZDogZGF0YS5qb2JJZCxcbiAgICAgIH0sXG4gICAgICBlcnJvcjogZGF0YS5lcnJvcixcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjb21wdXRpbmcgYW5hbHl0aWNzOicsIGVycm9yKVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdOZXR3b3JrIGVycm9yJyxcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG5ldyBzZXNzaW9uIElEXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVNlc3Npb25JZCgpOiBQcm9taXNlPHN0cmluZz4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7UFlUSE9OX0FQSV9VUkx9L2FwaS9zZXNzaW9uL2dlbmVyYXRlYCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgfSlcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZW5lcmF0ZSBzZXNzaW9uIElEJylcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgIHJldHVybiBkYXRhLnNlc3Npb25JZFxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBzZXNzaW9uIElEOicsIGVycm9yKVxuICAgIC8vIEZhbGxiYWNrOiBnZW5lcmF0ZSBjbGllbnQtc2lkZSBzZXNzaW9uIElEXG4gICAgcmV0dXJuIGBzZXNzaW9uXyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YFxuICB9XG59XG5cbi8qKlxuICogTG9naW4gdXNlclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9naW4oZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8eyB1c2VyOiBhbnk7IG1lc3NhZ2U6IHN0cmluZyB9Pj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7UFlUSE9OX0FQSV9VUkx9L2FwaS9sb2dpbmAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwsIHBhc3N3b3JkIH0pLFxuICAgIH0pXG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7IGRldGFpbDogJ1Vua25vd24gZXJyb3InIH0pKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvckRhdGEuZGV0YWlsIHx8IGVycm9yRGF0YS5lcnJvciB8fCBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c31gLFxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGRhdGEuc3VjY2VzcyB8fCB0cnVlLFxuICAgICAgZGF0YToge1xuICAgICAgICB1c2VyOiBkYXRhLnVzZXIsXG4gICAgICAgIG1lc3NhZ2U6IGRhdGEubWVzc2FnZSxcbiAgICAgIH0sXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9nZ2luZyBpbjonLCBlcnJvcilcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnTmV0d29yayBlcnJvcicsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IGRhc2hib2FyZCBzdGF0c1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3RhdHMoKTogUHJvbWlzZTxBcGlSZXNwb25zZTx7IHRvdGFsVXNlcnM6IG51bWJlcjsgbWVzc2FnZTogc3RyaW5nIH0+PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtQWVRIT05fQVBJX1VSTH0vYXBpL3N0YXRzYClcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgZGV0YWlsOiAnVW5rbm93biBlcnJvcicgfSkpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yRGF0YS5kZXRhaWwgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfWAsXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZGF0YS5zdWNjZXNzIHx8IHRydWUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRvdGFsVXNlcnM6IGRhdGEudG90YWxVc2VycyxcbiAgICAgICAgbWVzc2FnZTogZGF0YS5tZXNzYWdlLFxuICAgICAgfSxcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzdGF0czonLCBlcnJvcilcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnTmV0d29yayBlcnJvcicsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHNlc3Npb24gc3RhdHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNlc3Npb25TdGF0cyhzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8e1xuICBzZXNzaW9uSWQ6IHN0cmluZ1xuICBpc1ZhbGlkOiBib29sZWFuXG4gIHR0bDogbnVtYmVyXG4gIG1ldGFkYXRhOiBhbnlcbn0+PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtQWVRIT05fQVBJX1VSTH0vYXBpL3N0YXRzL3Nlc3Npb24/c2Vzc2lvbklkPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHNlc3Npb25JZCl9YClcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgZGV0YWlsOiAnVW5rbm93biBlcnJvcicgfSkpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yRGF0YS5kZXRhaWwgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfWAsXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc2Vzc2lvbklkOiBkYXRhLnNlc3Npb25JZCxcbiAgICAgICAgaXNWYWxpZDogZGF0YS5pc1ZhbGlkLFxuICAgICAgICB0dGw6IGRhdGEudHRsLFxuICAgICAgICBtZXRhZGF0YTogZGF0YS5tZXRhZGF0YSxcbiAgICAgIH0sXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgc2Vzc2lvbiBzdGF0czonLCBlcnJvcilcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnTmV0d29yayBlcnJvcicsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTGlzdCBHb29nbGUgRHJpdmUgZmlsZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxpc3RHb29nbGVEcml2ZUZpbGVzKGZvbGRlcklkPzogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTx7XG4gIGZpbGVzOiBBcnJheTx7XG4gICAgaWQ6IHN0cmluZ1xuICAgIG5hbWU6IHN0cmluZ1xuICAgIG1pbWVUeXBlOiBzdHJpbmdcbiAgICBtb2RpZmllZFRpbWU6IHN0cmluZ1xuICB9PlxufT4+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBmb2xkZXJJZFxuICAgICAgPyBgJHtQWVRIT05fQVBJX1VSTH0vYXBpL2dvb2dsZS1kcml2ZS9maWxlcz9mb2xkZXJJZD0ke2VuY29kZVVSSUNvbXBvbmVudChmb2xkZXJJZCl9YFxuICAgICAgOiBgJHtQWVRIT05fQVBJX1VSTH0vYXBpL2dvb2dsZS1kcml2ZS9maWxlc2BcbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybClcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgZGV0YWlsOiAnVW5rbm93biBlcnJvcicgfSkpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yRGF0YS5kZXRhaWwgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfWAsXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZGF0YS5zdWNjZXNzIHx8IHRydWUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGZpbGVzOiBkYXRhLmZpbGVzIHx8IFtdLFxuICAgICAgfSxcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsaXN0aW5nIEdvb2dsZSBEcml2ZSBmaWxlczonLCBlcnJvcilcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnTmV0d29yayBlcnJvcicsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVhZCBHb29nbGUgRHJpdmUgZmlsZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZEdvb2dsZURyaXZlRmlsZShcbiAgZmlsZUlkOiBzdHJpbmcsXG4gIHNoZWV0VHlwZTogc3RyaW5nID0gJ3NoaXBwaW5nJ1xuKTogUHJvbWlzZTxBcGlSZXNwb25zZTx7XG4gIGZpbGVOYW1lOiBzdHJpbmdcbiAgdG90YWxSb3dzOiBudW1iZXJcbiAgb3JpZ2luYWxSb3dzOiBudW1iZXJcbiAgZHVwbGljYXRlc1JlbW92ZWQ6IG51bWJlclxuICBoZWFkZXJzOiBzdHJpbmdbXVxuICB0b3RhbENvbHVtbnM6IG51bWJlclxuICBzZXNzaW9uSWQ6IHN0cmluZ1xuICBzaGVldFR5cGU6IHN0cmluZ1xuICBtZXNzYWdlOiBzdHJpbmdcbn0+PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtQWVRIT05fQVBJX1VSTH0vYXBpL2dvb2dsZS1kcml2ZS9yZWFkYCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBmaWxlSWQsIHNoZWV0VHlwZSB9KSxcbiAgICB9KVxuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoeyBkZXRhaWw6ICdVbmtub3duIGVycm9yJyB9KSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3JEYXRhLmRldGFpbCB8fCBlcnJvckRhdGEuZXJyb3IgfHwgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9YCxcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBkYXRhLnN1Y2Nlc3MgfHwgdHJ1ZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZmlsZU5hbWU6IGRhdGEuZmlsZU5hbWUsXG4gICAgICAgIHRvdGFsUm93czogZGF0YS50b3RhbFJvd3MsXG4gICAgICAgIG9yaWdpbmFsUm93czogZGF0YS5vcmlnaW5hbFJvd3MsXG4gICAgICAgIGR1cGxpY2F0ZXNSZW1vdmVkOiBkYXRhLmR1cGxpY2F0ZXNSZW1vdmVkLFxuICAgICAgICBoZWFkZXJzOiBkYXRhLmhlYWRlcnMsXG4gICAgICAgIHRvdGFsQ29sdW1uczogZGF0YS50b3RhbENvbHVtbnMsXG4gICAgICAgIHNlc3Npb25JZDogZGF0YS5zZXNzaW9uSWQsXG4gICAgICAgIHNoZWV0VHlwZTogZGF0YS5zaGVldFR5cGUsXG4gICAgICAgIG1lc3NhZ2U6IGRhdGEubWVzc2FnZSxcbiAgICAgIH0sXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVhZGluZyBHb29nbGUgRHJpdmUgZmlsZTonLCBlcnJvcilcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnTmV0d29yayBlcnJvcicsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IEdvb2dsZSBEcml2ZSBhdXRoIFVSTFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0R29vZ2xlRHJpdmVBdXRoVXJsKCk6IFByb21pc2U8QXBpUmVzcG9uc2U8e1xuICBhdXRoVXJsOiBzdHJpbmdcbiAgcmVkaXJlY3RVcmk6IHN0cmluZ1xuICBtZXNzYWdlOiBzdHJpbmdcbiAgaW5zdHJ1Y3Rpb25zOiBzdHJpbmdcbn0+PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtQWVRIT05fQVBJX1VSTH0vYXBpL2dvb2dsZS1kcml2ZS9hdXRoYClcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgZGV0YWlsOiAnVW5rbm93biBlcnJvcicgfSkpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yRGF0YS5kZXRhaWwgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfWAsXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZGF0YS5zdWNjZXNzIHx8IHRydWUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGF1dGhVcmw6IGRhdGEuYXV0aFVybCxcbiAgICAgICAgcmVkaXJlY3RVcmk6IGRhdGEucmVkaXJlY3RVcmksXG4gICAgICAgIG1lc3NhZ2U6IGRhdGEubWVzc2FnZSxcbiAgICAgICAgaW5zdHJ1Y3Rpb25zOiBkYXRhLmluc3RydWN0aW9ucyxcbiAgICAgIH0sXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBHb29nbGUgRHJpdmUgYXV0aCBVUkw6JywgZXJyb3IpXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ05ldHdvcmsgZXJyb3InLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCByYXcgc2hpcHBpbmcgZGF0YVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmF3U2hpcHBpbmdEYXRhKFxuICBzZXNzaW9uSWQ6IHN0cmluZyxcbiAgZmlsdGVycz86IHtcbiAgICBzdGFydERhdGU/OiBzdHJpbmcgfCBudWxsXG4gICAgZW5kRGF0ZT86IHN0cmluZyB8IG51bGxcbiAgICBvcmRlclN0YXR1cz86IHN0cmluZ1xuICAgIHBheW1lbnRNZXRob2Q/OiBzdHJpbmdcbiAgICBjaGFubmVsPzogc3RyaW5nXG4gICAgc2t1Pzogc3RyaW5nIHwgc3RyaW5nW11cbiAgICBwcm9kdWN0TmFtZT86IHN0cmluZyB8IHN0cmluZ1tdXG4gIH0sXG4gIGxpbWl0Pzogc3RyaW5nIHwgbnVtYmVyXG4pOiBQcm9taXNlPEFwaVJlc3BvbnNlPGFueVtdPj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG4gICAgcXVlcnlQYXJhbXMuYXBwZW5kKCdzZXNzaW9uSWQnLCBzZXNzaW9uSWQpXG4gICAgXG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgIGlmIChmaWx0ZXJzLnN0YXJ0RGF0ZSkgcXVlcnlQYXJhbXMuYXBwZW5kKCdzdGFydERhdGUnLCBmaWx0ZXJzLnN0YXJ0RGF0ZSlcbiAgICAgIGlmIChmaWx0ZXJzLmVuZERhdGUpIHF1ZXJ5UGFyYW1zLmFwcGVuZCgnZmlsdGVycy5lbmREYXRlJywgZmlsdGVycy5lbmREYXRlKVxuICAgICAgaWYgKGZpbHRlcnMub3JkZXJTdGF0dXMgJiYgZmlsdGVycy5vcmRlclN0YXR1cyAhPT0gJ0FsbCcpIHtcbiAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKCdvcmRlclN0YXR1cycsIGZpbHRlcnMub3JkZXJTdGF0dXMpXG4gICAgICB9XG4gICAgICBpZiAoZmlsdGVycy5wYXltZW50TWV0aG9kICYmIGZpbHRlcnMucGF5bWVudE1ldGhvZCAhPT0gJ0FsbCcpIHtcbiAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKCdwYXltZW50TWV0aG9kJywgZmlsdGVycy5wYXltZW50TWV0aG9kKVxuICAgICAgfVxuICAgICAgaWYgKGZpbHRlcnMuY2hhbm5lbCAmJiBmaWx0ZXJzLmNoYW5uZWwgIT09ICdBbGwnKSB7XG4gICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZCgnY2hhbm5lbCcsIGZpbHRlcnMuY2hhbm5lbClcbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXJzLnNrdSAmJiBmaWx0ZXJzLnNrdSAhPT0gJ0FsbCcpIHtcbiAgICAgICAgY29uc3Qgc2t1QXJyYXkgPSBBcnJheS5pc0FycmF5KGZpbHRlcnMuc2t1KSA/IGZpbHRlcnMuc2t1IDogW2ZpbHRlcnMuc2t1XVxuICAgICAgICBza3VBcnJheS5mb3JFYWNoKHNrdSA9PiBxdWVyeVBhcmFtcy5hcHBlbmQoJ3NrdScsIHNrdSkpXG4gICAgICB9XG4gICAgICBpZiAoZmlsdGVycy5wcm9kdWN0TmFtZSAmJiBmaWx0ZXJzLnByb2R1Y3ROYW1lICE9PSAnQWxsJykge1xuICAgICAgICBjb25zdCBwcm9kdWN0TmFtZUFycmF5ID0gQXJyYXkuaXNBcnJheShmaWx0ZXJzLnByb2R1Y3ROYW1lKSA/IGZpbHRlcnMucHJvZHVjdE5hbWUgOiBbZmlsdGVycy5wcm9kdWN0TmFtZV1cbiAgICAgICAgcHJvZHVjdE5hbWVBcnJheS5mb3JFYWNoKHByb2R1Y3ROYW1lID0+IHF1ZXJ5UGFyYW1zLmFwcGVuZCgncHJvZHVjdE5hbWUnLCBwcm9kdWN0TmFtZSkpXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChsaW1pdCkge1xuICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKCdsaW1pdCcsIFN0cmluZyhsaW1pdCkpXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7UFlUSE9OX0FQSV9VUkx9L2FwaS9hbmFseXRpY3MvcmF3LXNoaXBwaW5nPyR7cXVlcnlQYXJhbXMudG9TdHJpbmcoKX1gKVxuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoeyBkZXRhaWw6ICdVbmtub3duIGVycm9yJyB9KSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3JEYXRhLmRldGFpbCB8fCBlcnJvckRhdGEuZXJyb3IgfHwgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9YCxcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgZGF0YTogQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbXSxcbiAgICAgIGNvdW50OiBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YS5sZW5ndGggOiAwLFxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHJhdyBzaGlwcGluZyBkYXRhOicsIGVycm9yKVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdOZXR3b3JrIGVycm9yJyxcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgZmlsdGVyIG9wdGlvbnMgKGNoYW5uZWxzLCBTS1VzLCBwcm9kdWN0IG5hbWVzLCBldGMuKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RmlsdGVyT3B0aW9ucyhzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8e1xuICBjaGFubmVsczogc3RyaW5nW11cbiAgc2t1czogc3RyaW5nW11cbiAgcHJvZHVjdE5hbWVzOiBzdHJpbmdbXVxuICBzdGF0dXNlczogc3RyaW5nW11cbn0+PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtQWVRIT05fQVBJX1VSTH0vYXBpL2FuYWx5dGljcy9maWx0ZXItb3B0aW9ucz9zZXNzaW9uSWQ9JHtlbmNvZGVVUklDb21wb25lbnQoc2Vzc2lvbklkKX1gKVxuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoeyBkZXRhaWw6ICdVbmtub3duIGVycm9yJyB9KSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3JEYXRhLmRldGFpbCB8fCBlcnJvckRhdGEuZXJyb3IgfHwgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9YCxcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgZGF0YToge1xuICAgICAgICBjaGFubmVsczogZGF0YS5jaGFubmVscyB8fCBbXSxcbiAgICAgICAgc2t1czogZGF0YS5za3VzIHx8IFtdLFxuICAgICAgICBwcm9kdWN0TmFtZXM6IGRhdGEucHJvZHVjdE5hbWVzIHx8IFtdLFxuICAgICAgICBzdGF0dXNlczogZGF0YS5zdGF0dXNlcyB8fCBbXSxcbiAgICAgIH0sXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZmlsdGVyIG9wdGlvbnM6JywgZXJyb3IpXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ05ldHdvcmsgZXJyb3InLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCBUVEwgaW5mbyBmb3IgYW5hbHl0aWNzIGRhdGFcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFR0bEluZm8oc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPHtcbiAgc2hpcHBpbmc6IHsgdHRsOiBudW1iZXI7IGV4cGlyZXNBdDogc3RyaW5nIHwgbnVsbCB9XG4gIGFuYWx5dGljczogeyBba2V5OiBzdHJpbmddOiB7IHR0bDogbnVtYmVyOyBleHBpcmVzQXQ6IHN0cmluZyB8IG51bGwgfSB9XG59Pj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7UFlUSE9OX0FQSV9VUkx9L2FwaS9hbmFseXRpY3MvdHRsLWluZm8/c2Vzc2lvbklkPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHNlc3Npb25JZCl9YClcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgZGV0YWlsOiAnVW5rbm93biBlcnJvcicgfSkpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yRGF0YS5kZXRhaWwgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfWAsXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc2hpcHBpbmc6IGRhdGEuc2hpcHBpbmcgfHwgeyB0dGw6IDAsIGV4cGlyZXNBdDogbnVsbCB9LFxuICAgICAgICBhbmFseXRpY3M6IGRhdGEuYW5hbHl0aWNzIHx8IHt9LFxuICAgICAgfSxcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBUVEwgaW5mbzonLCBlcnJvcilcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnTmV0d29yayBlcnJvcicsXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiUFlUSE9OX0FQSV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfUFlUSE9OX0FQSV9VUkwiLCJidWlsZFF1ZXJ5U3RyaW5nIiwicGFyYW1zIiwic2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwic2Vzc2lvbklkIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsIm9yZGVyU3RhdHVzIiwicGF5bWVudE1ldGhvZCIsImNoYW5uZWwiLCJza3UiLCJza3VBcnJheSIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJwcm9kdWN0TmFtZSIsInByb2R1Y3ROYW1lQXJyYXkiLCJ0b1N0cmluZyIsImZldGNoQW5hbHl0aWNzIiwiZW5kcG9pbnQiLCJxdWVyeVN0cmluZyIsInVybCIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsInN0YXR1cyIsInN1Y2Nlc3MiLCJkYXRhIiwiY291bnQiLCJlcnJvckRhdGEiLCJqc29uIiwiY2F0Y2giLCJkZXRhaWwiLCJlcnJvciIsImxlbmd0aCIsImNvbnNvbGUiLCJtZXNzYWdlIiwiY29tcHV0ZUFuYWx5dGljcyIsImZpbHRlcnMiLCJhc3luY01vZGUiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1bmRlZmluZWQiLCJqb2JJZCIsImdlbmVyYXRlU2Vzc2lvbklkIiwiRXJyb3IiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInN1YnN0ciIsImxvZ2luIiwiZW1haWwiLCJwYXNzd29yZCIsInVzZXIiLCJnZXRTdGF0cyIsInRvdGFsVXNlcnMiLCJnZXRTZXNzaW9uU3RhdHMiLCJlbmNvZGVVUklDb21wb25lbnQiLCJpc1ZhbGlkIiwidHRsIiwibWV0YWRhdGEiLCJsaXN0R29vZ2xlRHJpdmVGaWxlcyIsImZvbGRlcklkIiwiZmlsZXMiLCJyZWFkR29vZ2xlRHJpdmVGaWxlIiwiZmlsZUlkIiwic2hlZXRUeXBlIiwiZmlsZU5hbWUiLCJ0b3RhbFJvd3MiLCJvcmlnaW5hbFJvd3MiLCJkdXBsaWNhdGVzUmVtb3ZlZCIsInRvdGFsQ29sdW1ucyIsImdldEdvb2dsZURyaXZlQXV0aFVybCIsImF1dGhVcmwiLCJyZWRpcmVjdFVyaSIsImluc3RydWN0aW9ucyIsImdldFJhd1NoaXBwaW5nRGF0YSIsImxpbWl0IiwicXVlcnlQYXJhbXMiLCJTdHJpbmciLCJnZXRGaWx0ZXJPcHRpb25zIiwiY2hhbm5lbHMiLCJza3VzIiwicHJvZHVjdE5hbWVzIiwic3RhdHVzZXMiLCJnZXRUdGxJbmZvIiwic2hpcHBpbmciLCJleHBpcmVzQXQiLCJhbmFseXRpY3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api-client.ts\n"));

/***/ })

}]);